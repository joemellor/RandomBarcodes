__author__ = 'joemellor'

import random
import itertools

def dameraulevenshtein_distance(seq1, seq2):
    # codesnippet:D0DE4716-B6E6-4161-9219-2903BF8F547F
    # Conceptually, this is based on a len(seq1) + 1 * len(seq2) + 1 matrix.
    # However, only the current and two previous rows are needed at once,
    # so we only store those.
    oneago = None
    thisrow = range(1, len(seq2) + 1) + [0]
    for x in xrange(len(seq1)):
        # Python lists wrap around for negative indices, so put the
        # leftmost column at the *end* of the list. This matches with
        # the zero-indexed strings and saves extra calculation.
        twoago, oneago, thisrow = oneago, thisrow, [0] * len(seq2) + [x + 1]
        for y in xrange(len(seq2)):
            delcost = oneago[y] + 1
            addcost = thisrow[y - 1] + 1
            subcost = oneago[y - 1] + (seq1[x] != seq2[y])
            thisrow[y] = min(delcost, addcost, subcost)
            # This block deals with transpositions
            if (x > 0 and y > 0 and seq1[x] == seq2[y - 1]
                and seq1[x-1] == seq2[y] and seq1[x] != seq2[y]):
                thisrow[y] = min(thisrow[y], twoago[y - 2] + 1)
    return thisrow[len(seq2) - 1]
def hamming_distance(s1, s2):
    assert len(s1) == len(s2)
    return sum(ch1 != ch2 for ch1, ch2 in zip(s1, s2))
def base10toN(num,n):
    """Change a  to a base-n number.
    Up to base-36 is supported without special notation."""
    num_rep={10:'a',
         11:'b',
         12:'c',
         13:'d',
         14:'e',
         15:'f',
         16:'g',
         17:'h',
         18:'i',
         19:'j',
         20:'k',
         21:'l',
         22:'m',
         23:'n',
         24:'o',
         25:'p',
         26:'q',
         27:'r',
         28:'s',
         29:'t',
         30:'u',
         31:'v',
         32:'w',
         33:'x',
         34:'y',
         35:'z'}
    new_num_string=''
    current=num
    while current!=0:
        remainder=current%n
        if 36>remainder>9:
            remainder_string=num_rep[remainder]
        elif remainder>=36:
            remainder_string='('+str(remainder)+')'
        else:
            remainder_string=str(remainder)
        new_num_string=remainder_string+new_num_string
        current=current/n
    return new_num_string

barcodelist = list()



f = open('96barcodes.txt', 'r')

for line in f:
    barcodelist.append(line.rstrip("\n"))
f.closed

print "\n"

quitsignal = False
while (len(barcodelist) < 400 and quitsignal == False):
    acceptnewbarcode = False
    numberoftries = 0
    while (acceptnewbarcode == False and numberoftries < 20):
        newbarcode = ''.join([random.choice('ACGT') for x in range(8)])
        barcodesmeetingthreshold = 0
        numberoftries += 1
        for barcode in barcodelist:
            if (hamming_distance(newbarcode,barcode) > 2):
                barcodesmeetingthreshold += 1
        if (barcodesmeetingthreshold == len(barcodelist)):
            acceptnewbarcode = True
            barcodelist.append(newbarcode)
        if (numberoftries >= 10):
            quitsignal = True
            break


for seq in barcodelist:
    print seq

print len(barcodelist)

    






